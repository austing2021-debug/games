<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>æ‰‹æŒ‡è¿·å®®</title>
    <style>
        body { margin: 0; background: #3e2723; overflow: hidden; touch-action: none; font-family: sans-serif; }
        header { position: absolute; top: 0; left: 0; width: 100%; padding: 10px; display: flex; gap: 10px; z-index: 10; pointer-events: none; }
        select, button, a { pointer-events: auto; background: white; border: none; padding: 8px 15px; border-radius: 15px; font-weight: bold; text-decoration: none; color: #333; }
        canvas { display: block; background: #5d4037; }
        .msg { position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(255,255,255,0.9); padding: 20px; border-radius: 20px; text-align: center; display: none; }
    </style>
</head>
<body>
    <header>
        <a href="index.html">â—€</a>
        <select id="diff" onchange="init()">
            <option value="5">Lv 1</option>
            <option value="8">Lv 2</option>
            <option value="12">Lv 3</option>
            <option value="18">Lv 4</option>
            <option value="25">Lv 5</option>
        </select>
        <select id="type" onchange="init()">
            <option value="maze">è¿·å®®ç‰ˆ (æœ‰ç‰†)</option>
            <option value="line">ç·šæ¢ç‰ˆ (é€£é€£çœ‹)</option>
        </select>
        <button onclick="init()">é‡ç½®</button>
    </header>

    <canvas id="cvs"></canvas>

    <div class="msg" id="winMsg">
        <h1>æŠµé”å‡ºå£! ğŸš€</h1>
        <button onclick="init()">å†ç©ä¸€æ¬¡</button>
    </div>

    <script>
        const canvas = document.getElementById('cvs');
        const ctx = canvas.getContext('2d');
        let cols, rows, size, grid = [], player = {x:0, y:0};
        let isDrawing = false;
        
        window.onload = init;
        window.onresize = init;

        function init() {
            document.getElementById('winMsg').style.display = 'none';
            const diff = parseInt(document.getElementById('diff').value);
            const type = document.getElementById('type').value;
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            cols = diff; 
            rows = Math.floor(cols * (canvas.height / canvas.width));
            size = Math.min(canvas.width/cols, canvas.height/rows);

            // ç”Ÿæˆè¿·å®®
            grid = [];
            for(let y=0; y<rows; y++) {
                let r = [];
                for(let x=0; x<cols; x++) r.push({x, y, walls:[1,1,1,1], visited:false});
                grid.push(r);
            }
            
            // DFS ç®—æ³•ç”Ÿæˆ
            let stack = [], current = grid[0][0];
            current.visited = true;
            do {
                let next = getNeighbor(current);
                if(next) {
                    next.visited = true;
                    stack.push(current);
                    removeWall(current, next);
                    current = next;
                } else if(stack.length) current = stack.pop();
            } while(stack.length);

            // ç¹ªè£½åº•åœ–
            drawMap(type);
        }

        function getNeighbor(c) {
            let n = [], {x,y} = c;
            if(y>0 && !grid[y-1][x].visited) n.push(grid[y-1][x]);
            if(x<cols-1 && !grid[y][x+1].visited) n.push(grid[y][x+1]);
            if(y<rows-1 && !grid[y+1][x].visited) n.push(grid[y+1][x]);
            if(x>0 && !grid[y][x-1].visited) n.push(grid[y][x-1]);
            return n.length ? n[Math.floor(Math.random()*n.length)] : undefined;
        }

        function removeWall(a, b) {
            let dx = a.x - b.x, dy = a.y - b.y;
            if(dx === 1) { a.walls[3]=0; b.walls[1]=0; }
            if(dx === -1) { a.walls[1]=0; b.walls[3]=0; }
            if(dy === 1) { a.walls[0]=0; b.walls[2]=0; }
            if(dy === -1) { a.walls[2]=0; b.walls[0]=0; }
        }

        function drawMap(type) {
            ctx.fillStyle = '#3e2723'; ctx.fillRect(0,0,canvas.width, canvas.height);
            
            if(type === 'maze') {
                ctx.strokeStyle = '#8d6e63'; ctx.lineWidth = 4;
                for(let y=0; y<rows; y++) for(let x=0; x<cols; x++) {
                    let c = grid[y][x], px = x*size, py = y*size;
                    ctx.beginPath();
                    if(c.walls[0]) {ctx.moveTo(px,py); ctx.lineTo(px+size,py);}
                    if(c.walls[1]) {ctx.moveTo(px+size,py); ctx.lineTo(px+size,py+size);}
                    if(c.walls[2]) {ctx.moveTo(px+size,py+size); ctx.lineTo(px,py+size);}
                    if(c.walls[3]) {ctx.moveTo(px,py+size); ctx.lineTo(px,py);}
                    ctx.stroke();
                }
            } else {
                // ç·šæ¢ç‰ˆï¼šåªç•«è·¯å¾‘é»
                ctx.fillStyle = '#6d4c41';
                for(let y=0; y<rows; y++) for(let x=0; x<cols; x++) {
                    ctx.beginPath(); ctx.arc(x*size+size/2, y*size+size/2, size/10, 0, Math.PI*2); ctx.fill();
                }
            }

            // èµ·é»çµ‚é»
            ctx.font = `${size/1.5}px Arial`; ctx.textAlign='center'; ctx.textBaseline='middle';
            ctx.fillText('ğŸŒ±', size/2, size/2);
            ctx.fillText('ğŸš€', (cols-1)*size+size/2, (rows-1)*size+size/2);
        }

        // è§¸æ§ç•«ç·šé‚è¼¯
        function getPos(e) {
            const t = e.touches ? e.touches[0] : e;
            return {x: t.clientX, y: t.clientY};
        }

        ['mousedown', 'touchstart'].forEach(ev => canvas.addEventListener(ev, e => {
            isDrawing = true;
            const p = getPos(e);
            ctx.beginPath(); ctx.moveTo(p.x, p.y);
            ctx.strokeStyle = '#ffff00'; ctx.lineWidth = size/4; ctx.lineCap = 'round';
        }));

        ['mousemove', 'touchmove'].forEach(ev => canvas.addEventListener(ev, e => {
            if(!isDrawing) return;
            e.preventDefault();
            const p = getPos(e);
            ctx.lineTo(p.x, p.y); ctx.stroke();
            
            // ç°¡å–®åˆ¤æ–·çµ‚é»
            const endX = (cols-1)*size, endY = (rows-1)*size;
            if(p.x > endX && p.y > endY) {
                document.getElementById('winMsg').style.display = 'block';
                isDrawing = false;
            }
        }, {passive: false}));

        ['mouseup', 'touchend'].forEach(ev => canvas.addEventListener(ev, () => isDrawing = false));

    </script>
</body>
</html>
